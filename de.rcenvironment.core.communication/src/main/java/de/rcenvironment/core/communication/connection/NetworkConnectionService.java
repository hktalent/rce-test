/*
 * Copyright (C) 2006-2012 DLR, Germany
 * 
 * All rights reserved
 * 
 * http://www.rcenvironment.de/
 */

package de.rcenvironment.core.communication.connection;

import java.util.Map;
import java.util.concurrent.Future;

import de.rcenvironment.core.communication.model.NetworkConnection;
import de.rcenvironment.core.communication.model.NetworkContactPoint;
import de.rcenvironment.core.communication.model.NetworkResponse;
import de.rcenvironment.core.communication.model.NetworkResponseHandler;
import de.rcenvironment.rce.communication.CommunicationException;

/**
 * A service that manages the creation of abstract network connections.
 * 
 * TODO extend documentation after API is settled
 * 
 * @author Robert Mischke
 */
public interface NetworkConnectionService {

    /**
     * Fetches the {@link NetworkConnectionEndpointHandler} to use for incoming requests. Used for
     * processing routed messages.
     * 
     * @return an initialized {@link NetworkConnectionEndpointHandler} instance
     */
    NetworkConnectionEndpointHandler getConnectionEndpointHandler();

    /**
     * Initiates an asynchronous connection attempt.
     * 
     * TODO extend documentation after API is settled
     * 
     * @param ncp the {@link NetworkContactPoint} describing the "physical" destination to connect
     *        to, and the transport to use
     * @param allowDuplex for transports that support bidirectional message flow over a single
     *        established connection, this flag determines whether a message path (represented as a
     *        {@link NetworkConnection}) from the destination back to the local node should be
     *        created; if the transport does not support this, the flag has no effect
     * @return a {@link Future} that can be used to wait for the end of the connection attempt, and
     *         to retrieve the created {@link NetworkConnection}; TODO specify Future behaviour on
     *         connection failure
     * @throws CommunicationException if the {@link NetworkContactPoint} specifies an invalid or
     *         unknown transport
     */
    Future<NetworkConnection> connect(NetworkContactPoint ncp, boolean allowDuplex) throws CommunicationException;

    /**
     * Closes all established (logical) {@link NetworkConnection}s. Usually called on shutdown.
     */
    void closeAllOutgoingConnections();

    /**
     * Sends a request containing the given payload and metadata into the given connection. The
     * response is returned via the provided {@link NetworkResponseHandler}.
     * 
     * @param messageBytes the byte array form of the payload
     * @param metaData the metadata for the request
     * @param connection the connection to send to
     * @param responseHandler the response handler
     */
    void sendRequest(byte[] messageBytes, Map<String, String> metaData,
        NetworkConnection connection, NetworkResponseHandler responseHandler);

    /**
     * Convenience method that sends a request containing the given payload and metadata into the
     * given connection, and returns a {@link Future} for the received response.
     * 
     * @param messageBytes the byte array form of the payload
     * @param metaData the metadata for the request
     * @param connection the connection to send to
     * @return a {@link Future} providing the associated {@link NetworkResponse}
     */
    Future<NetworkResponse> sendRequest(byte[] messageBytes,
        final Map<String, String> metaData, final NetworkConnection connection);

    /**
     * Adds a new request handler to the processing chain. The handlers are invoked in the order
     * they were added, and the first non-null response generated by a handler is used. Once a
     * non-null response was generated, no further handlers are invoked for the same request.
     * 
     * @param handler the handler to add
     */
    void addRequestHandler(NetworkRequestHandler handler);

    /**
     * Registers an asynchronous listener for connection events.
     * 
     * @param listener the listener to add
     */
    // TODO rename when/if class is renamed
    void addConnectionListener(NetworkConnectionListener listener);

    /**
     * Unregisters an asynchronous listener for connection events.
     * 
     * @param listener the listener to remove
     */
    void removeConnectionListener(NetworkConnectionListener listener);

    /**
     * Starts a local server at the given {@link NetworkContactPoint}. The type of server is
     * determined by the transport id of the contact point.
     * 
     * The host part of the {@link NetworkContactPoint} is taken as the bind address for the
     * service; therefore, the {@link NetworkContactPoint} used for this method may be different
     * from the one that is announced for network peers to connect to. For example, a service may
     * bind to "0.0.0.0", but may use an externally-visible IP or host name for its public contact
     * point.
     * 
     * To shut down the server, use {@link ServerContactPoint#shutDown()}. The reference to the
     * transport that created this {@link ServerContactPoint} is stored internally to avoid the case
     * where it goes away on the OSGi service level before network shutdown occurs.
     * 
     * @param ncp the {@link NetworkContactPoint} used to identify the type of transport, the bind
     *        address, and the network port for the server; if it matches an already-running server,
     *        an {@link IllegalStateException} is thrown
     * @return the {@link ServerContactPoint} handle for the started server
     * @throws CommunicationException on startup failure
     */
    ServerContactPoint startServer(NetworkContactPoint ncp) throws CommunicationException;

    /**
     * Checks the health status (i.e., the liveliness) of the outgoing connection that has been
     * idle/unchecked for the longest time. If the connection fails the test, it is closed.
     */
    void triggerConnectionHealthChecks();
}
