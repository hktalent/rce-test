/*
 * Copyright (C) 2006-2011 DLR, Germany
 * 
 * All rights reserved
 * 
 * http://www.rcenvironment.de/
 */
 
package de.rcenvironment.rce.components.gui.optimizer.view;

import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.rcenvironment.rce.communication.PlatformIdentifier;
import de.rcenvironment.rce.components.optimizer.commons.Dimension;
import de.rcenvironment.rce.components.optimizer.commons.Measure;
import de.rcenvironment.rce.components.optimizer.commons.OptimizerReceiver;
import de.rcenvironment.rce.components.optimizer.commons.OptimizerResultSet;
import de.rcenvironment.rce.components.optimizer.commons.ResultSet;
import de.rcenvironment.rce.components.optimizer.commons.ResultStructure;
import de.rcenvironment.rce.components.optimizer.commons.SimpleOptimizerResultService;

/**
 * Study holding values generated by the {@link ParametricStudyComponent}.
 * @author Sascha Zur
 */
public final class OptimizerDatastore extends ResultSet {

    private static final long serialVersionUID = 990775937058384209L;

    // needed to hold reference otherwise it is can not be called back
    private static DatasetNotificationSubscriber notificationSubscriber;

    private final List<OptimizerResultSet> datasets = Collections.synchronizedList(new LinkedList<OptimizerResultSet>());

    private final List<OptimizerResultSetAddListener> listeners = new LinkedList<OptimizerResultSetAddListener>();

    private final Map<String, Double> minValues = new HashMap<String, Double>();

    private final Map<String, Double> maxValues = new HashMap<String, Double>();
    
    public OptimizerDatastore(final String identifier, final String title, final ResultStructure structure) {
        super(identifier, title, structure);
    }

    /**
     * @param dataset new values.
     */
    public void addDataset(final OptimizerResultSet dataset) {
        datasets.add(dataset);
        fireDatasetAdd(dataset);
        for (final Dimension dimension : getStructure().getDimensions()) {
            adjustMinMaxRange(dataset, dimension.getName());
        }
        for (final Measure measure : getStructure().getMeasures()) {
            adjustMinMaxRange(dataset, measure.getName());
        }
    }

    private void adjustMinMaxRange(final OptimizerResultSet dataset,
            final String key) {
        final Serializable value = dataset.getValue(key);
        if (value instanceof Number) {
            final Double doubleValue = ((Number) value).doubleValue();
            if (minValues.get(key) == null
                    || minValues.get(key) > doubleValue) {
                minValues.put(key, doubleValue);
            }
            if (maxValues.get(key) == null
                    || maxValues.get(key) < doubleValue) {
                maxValues.put(key, doubleValue);
            }
        }
    }

    public Collection<OptimizerResultSet> getDatasets() {
        return Collections.unmodifiableCollection(datasets);
    }

    public int getDatasetCount() {
        return datasets.size();
    }

    /**
     * @param key of the relevant value chain.
     * @return the minimum value of the chain.
     */
    public Double getMinValue(final String key) {
        return minValues.get(key);
    }

    /**
     * @param key of the relevant value chain.
     * @return the maximum value of the chain.
     */
    public Double getMaxValue(final String key) {
        return maxValues.get(key);
    }

    /**
     * Connects a {@link ResultReceiver} to the {@link StudyPublisher}.
     * @param identifier the unique identifier
     * @param platform the platform to receive updates from
     * @return created {@link OptimizerDatastore}.
     */
    public static OptimizerDatastore connect(final String identifier, final PlatformIdentifier platform) {
        final SimpleOptimizerResultService parametricStudyService = new SimpleOptimizerResultService();
        final OptimizerReceiver receiver = parametricStudyService.createReceiver(identifier, platform);
        final OptimizerDatastore datastore = new OptimizerDatastore(identifier,
                receiver.getStudy().getTitle(), receiver.getStudy().getStructure());
        notificationSubscriber = new DatasetNotificationSubscriber(datastore);
        receiver.setNotificationSubscriber(notificationSubscriber);
        receiver.initialize();
        return datastore;
    }

    /**
     * @param listener for {@link StudyDataset}to add.
     */
    public void addDatasetAddListener(final OptimizerResultSetAddListener listener) {
        listeners.add(listener);
    }

    /**
     * @param listener for {@link StudyDataset} to remove.
     */
    public void removeDatasetAddListener(final OptimizerResultSetAddListener listener) {
        listeners.remove(listener);
    }

    private void fireDatasetAdd(final OptimizerResultSet dataset) {
        final OptimizerResultSetAddListener[] listenersArray = listeners.toArray(new OptimizerResultSetAddListener[0]);
        for (final OptimizerResultSetAddListener listener : listenersArray) {
            try {
                listener.handleStudyDatasetAdd(dataset);
            } catch (RuntimeException e) {
                e = null; // ignore
            }
        }
    }

    /**
     * Needs to be implemented by classes which are interested in {@link StudyDataset}.
     * @author Doreen Seider
     */
    public interface OptimizerResultSetAddListener {

        /**
         * @param dataset the new {@link StudyDataset}.
         */
        void handleStudyDatasetAdd(final OptimizerResultSet dataset);

    }

}
